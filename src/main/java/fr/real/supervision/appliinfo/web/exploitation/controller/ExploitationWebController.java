package fr.real.supervision.appliinfo.web.exploitation.controller;

import java.util.Map;
import java.util.Optional;

import javax.servlet.http.HttpServletResponse;

import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.actuate.health.HealthComponent;
import org.springframework.boot.actuate.health.HealthEndpoint;
import org.springframework.boot.actuate.health.Status;
import org.springframework.boot.actuate.health.SystemHealth;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import fr.real.supervision.appliinfo.connector.sms.SmsProperties;
import kong.unirest.HttpResponse;
import kong.unirest.JsonNode;
import kong.unirest.Unirest;
import lombok.RequiredArgsConstructor;

@Controller
@RequiredArgsConstructor
public class ExploitationWebController {

	private static final Logger LOGGER = LoggerFactory.getLogger(ExploitationWebController.class);

	private final SmsProperties properties;
	private final HealthEndpoint healthEndpoint;

	@Value("${info.app.version}")
	String applicationVersion;

	@GetMapping("/diagnostic")
	public String diagnostic(Model model, HttpServletResponse response) {

		HealthComponent hc = healthEndpoint.health();
		Map<String, HealthComponent> details = ((SystemHealth) hc).getComponents();

		model.addAttribute("healthValues", details);
		model.addAttribute("version", applicationVersion);
		model.addAttribute("remainingSMS", getSoldeSMS());

		return "diagnostic";
	}

	@GetMapping("/diagnostic/SoldeSMS")
	public ResponseEntity<String> getSMSCreditsValue() {
		return ResponseEntity.of(Optional.of(getSoldeSMS()));
	}

	@GetMapping("/exploitation")
	@ResponseBody
	public ResponseEntity<String> exploitation() {
		return ResponseEntity.status(HttpStatus.OK)
				.body(Status.UP.equals(healthEndpoint.health().getStatus()) ? "OK" : "KO");

	}

	@GetMapping("/version")
	@ResponseBody
	public ResponseEntity<String> version() {
		return ResponseEntity.status(HttpStatus.OK).body(applicationVersion);
	}

	@GetMapping("/ping")
	@ResponseBody
	public ResponseEntity<String> ping() {
		return exploitation();
	}

	private String getSoldeSMS() {

		String source = "SMSFactor";
		String subject = "sms restants";
		String apiUrl = properties.getApiUrl() + "/credits";
		String apiToken = String.format("Bearer %s", properties.getApiToken());

		boolean result = false;

		JSONObject jsonResponse = null;
		try {

			LOGGER.info(String.format("Envoi d'une requete a %s pour récupérer les %s", source, subject));

			HttpResponse<JsonNode> response = Unirest.get(apiUrl)
					.proxy(properties.getProxyHost(), properties.getProxyPort()).header("Authorization", apiToken)
					.header("Accept", "application/json").asJson();

			jsonResponse = response.getBody().getObject();
			// String.format("GenieKey %s", properties.getOpsGenieToken())

			// La reponse doit avoir un statut 400 Bad Request (car la requete avait un body
			// vide), et doit contenir un requestId non null
			if (response.getStatus() == 400) {
				result = true;
			}

		} catch (Exception e) {
			LOGGER.error(String.format("la requete au serveur %s a echoue", source), e);
		}

		return jsonResponse.get("credits").toString();
	}

}
